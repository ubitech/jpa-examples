/*
 *  Copyright 2015-2016 PaaSword project, http://www.paasword.eu/
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package eu.paasword;

import eu.paasword.dao.InventoryitemRepository;
import eu.paasword.dao.InventoryitemtypeRepository;
import eu.paasword.dao.ProjectRepository;
import eu.paasword.dao.UserRepository;
import eu.paasword.dao.UsertypeRepository;
import eu.paasword.model.Inventoryitem;
import eu.paasword.model.Inventoryitemtype;
import eu.paasword.model.Project;
import eu.paasword.model.User;
import eu.paasword.model.Usertype;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;
import javassist.bytecode.stackmap.TypeData.ClassName;
import javax.transaction.Transactional;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.transaction.TransactionConfiguration;

/**
 *
 * @author Panagiotis Gouvas (pgouvas@ubitech.eu)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@TransactionConfiguration(defaultRollback = false)
public class ServiceTest {

    private static final Logger logger = Logger.getLogger(ClassName.class.getName());

    public ServiceTest() {
    }

    @BeforeClass
    public static void setUpClass() {
    }

    @AfterClass
    public static void tearDownClass() {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }

    @Test
    public void test() {

    }

    @Autowired
    InventoryitemRepository invir;
    @Autowired
    InventoryitemtypeRepository invitr;
    @Autowired
    ProjectRepository prr;
    @Autowired
    UserRepository usrr;
    @Autowired
    UsertypeRepository usrtr;

    @Test
    public void testWiring() {
        logger.info("Test Autowiring of all imported repositories");
        Assert.assertNotNull(invir);
        Assert.assertNotNull(invitr);
        Assert.assertNotNull(prr);
        Assert.assertNotNull(usrr);
        Assert.assertNotNull(usrtr);
        logger.info("Test testWiring finished successfully");
    }//EOM    

    /*
     *   This method will execute several test-cases. It will be used to get the raw
     *   SQL queries that is autogenerated by Hibernate. Before you run the queries
     *   you should remove all data from your database and you should enable 
     *   spring.jpa.show-sql = true in the application.properties 
     */
    @Ignore
    @Test
    @Transactional
    public void testInitializeDatabase() throws ParseException {
        logger.info("Test testInitializeDatabase initialized");
        /*
         * Batch-1: Insert a simple user. This is the simplest case
         * In a clean installation of the database there will be no Usertype.
         * We will attempt to create one User object without filling the Usertype
         * Since Usertype is declared as "optional = false" we expect runtime exception
         */
//        try {
//            User newuser = new User();
//            newuser.setName("Panagiotis Gouvas");
//            logger.info("CASE-1 execution");
//            usrr.save(newuser);
//        } catch (Exception ex1) {
//            logger.info("Exception generated because Usertype was not provided");
//        }
        /*
         * Indeed the save statement was interpreted to the following SQL 
         * insert into user (name, usertype) values (?, ?)
         * however the following exception was generated: Column 'usertype' cannot be null
         * since an SQL Error (1048) was generated due to constraint violation
         * Please note that if "optional = false" changes to "optional = true" then the insert query
         * will be executed with the second argument as NULL
         */

        /*
         * Batch-2: Initialize the database by putting sample usertypes, inventoryitemtypes, users, inventoryitems and projects
         */
        //initialize usertypes (3 indicative types)  
        Usertype ust1 = new Usertype();
        ust1.setTypename("UserType1");
        usrtr.save(ust1);
        Usertype ust2 = new Usertype();
        ust2.setTypename("UserType2");
        usrtr.save(ust2);
        Usertype ust3 = new Usertype();
        ust3.setTypename("UserType3");
        usrtr.save(ust3);

        //initialize users (3 users per each usertype)
        User user11 = new User();
        user11.setName("User11");
        user11.setUsertype(ust1);
        user11.setSalary(1100);
        usrr.save(user11);
        User user12 = new User();
        user12.setName("User12");
        user12.setUsertype(ust1);
        user12.setSalary(1500);
        usrr.save(user12);
        User user13 = new User();
        user13.setName("User13");
        user13.setUsertype(ust1);
        user13.setSalary(1900);
        usrr.save(user13);

        User user21 = new User();
        user21.setName("User21");
        user21.setUsertype(ust2);
        user21.setSalary(2100);
        usrr.save(user21);
        User user22 = new User();
        user22.setName("User22");
        user22.setUsertype(ust2);
        user22.setSalary(2500);
        usrr.save(user22);
        User user23 = new User();
        user23.setName("User23");
        user23.setUsertype(ust2);
        user23.setSalary(2900);
        usrr.save(user23);

        User user31 = new User();
        user31.setName("User31");
        user31.setUsertype(ust3);
        user31.setSalary(3100);
        usrr.save(user31);
        User user32 = new User();
        user32.setName("User32");
        user32.setUsertype(ust3);
        user32.setSalary(3500);
        usrr.save(user32);
        User user33 = new User();
        user33.setName("User33");
        user33.setUsertype(ust3);
        user33.setSalary(3900);
        usrr.save(user33);

        //initialize inventorytypes (3 indicative types)       
        Inventoryitemtype inventoryitemtype1 = new Inventoryitemtype();
        inventoryitemtype1.setItemtypename("InventoryType1");
        invitr.save(inventoryitemtype1);
        Inventoryitemtype inventoryitemtype2 = new Inventoryitemtype();
        inventoryitemtype2.setItemtypename("InventoryType2");
        invitr.save(inventoryitemtype2);
        Inventoryitemtype inventoryitemtype3 = new Inventoryitemtype();
        inventoryitemtype3.setItemtypename("InventoryType3");
        invitr.save(inventoryitemtype3);

        //initialize inventoryitems (3 items per each item type)
        Inventoryitem inv11 = new Inventoryitem();
        inv11.setItemname("Item11");
        inv11.setInventoryitemtype(inventoryitemtype1);
        invir.save(inv11);
        Inventoryitem inv12 = new Inventoryitem();
        inv12.setItemname("Item12");
        inv12.setInventoryitemtype(inventoryitemtype1);
        invir.save(inv12);
        Inventoryitem inv13 = new Inventoryitem();
        inv13.setItemname("Item13");
        inv13.setInventoryitemtype(inventoryitemtype1);
        invir.save(inv13);

        Inventoryitem inv21 = new Inventoryitem();
        inv21.setItemname("Item21");
        inv21.setInventoryitemtype(inventoryitemtype2);
        invir.save(inv21);
        Inventoryitem inv22 = new Inventoryitem();
        inv22.setItemname("Item22");
        inv22.setInventoryitemtype(inventoryitemtype2);
        invir.save(inv22);
        Inventoryitem inv23 = new Inventoryitem();
        inv23.setItemname("Item23");
        inv23.setInventoryitemtype(inventoryitemtype2);
        invir.save(inv23);

        Inventoryitem inv31 = new Inventoryitem();
        inv31.setItemname("Item31");
        inv31.setInventoryitemtype(inventoryitemtype3);
        invir.save(inv31);
        Inventoryitem inv32 = new Inventoryitem();
        inv32.setItemname("Item32");
        inv32.setInventoryitemtype(inventoryitemtype3);
        invir.save(inv32);
        Inventoryitem inv33 = new Inventoryitem();
        inv33.setItemname("Item33");
        inv33.setInventoryitemtype(inventoryitemtype3);
        invir.save(inv33);

        //initialize projects (3 indicative projects)        
        Project project1 = new Project();
        project1.setName("Project1");
        project1.setBudget(1000000);
        project1.setIsfinished(false);
        project1.setStartdate( (new SimpleDateFormat("dd-MM-yyyy")).parse("1-1-2001") );
        prr.save(project1);
        Project project2 = new Project();
        project2.setName("Project2");
        project2.setBudget(2000000);
        project2.setIsfinished(false);   
        //project2.setStartdate( (new SimpleDateFormat("dd-MM-yyyy")).parse("1-1-2001") );   //deliberately left blank     
        prr.save(project2);
        Project project3 = new Project();
        project3.setName("Project3");
        project3.setBudget(3000000);
        project3.setIsfinished(false);
        project3.setStartdate( (new SimpleDateFormat("dd-MM-yyyy")).parse("1-1-2003") );        
        prr.save(project3);
        Project project4 = new Project();
        project4.setName("Project4");
        project4.setBudget(4000000);
        //project4.setIsfinished(true);     //we do not know if it is finished
        prr.save(project4);
        Project project5 = new Project();
        project5.setName("Project5");
        project5.setBudget(5000000);
        project3.setStartdate( (new SimpleDateFormat("dd-MM-yyyy")).parse("1-1-2005") );                
        project5.setIsfinished(true);        
        prr.save(project5);

        /*
         * Batch-3: Perform Many to Many associations associations
         * project_users first
         * project1 -> user11 user22 user33
         * project2 -> user12 user23 user31
         * project3 -> user13 user21 user32
         *
         * project_inventory
         * project1 -> inv12 inv23 inv32
         * project2 -> inv13 inv21 inv33 
         * project3 -> inv11 inv22 inv31
         */
        Set<User> usersforproject1 = new HashSet<User>();
        usersforproject1.add(user11);
        project1.setUsers(usersforproject1);
        project1.getUsers().add(user22);
        //project1.getUsers().add(user33);  //user9 is not participating in any project

        Set<User> usersforproject2 = new HashSet<User>();
        usersforproject2.add(user12);
        project2.setUsers(usersforproject2);
        project2.getUsers().add(user23);
        project2.getUsers().add(user31);

        Set<User> usersforproject3 = new HashSet<User>();
        usersforproject3.add(user13);
        project3.setUsers(usersforproject3);
        project3.getUsers().add(user21);
        project3.getUsers().add(user32);
        project3.getUsers().add(user11); //double insert

    }//EoM

    /*
     * Sample Queries in the initialized database
     */
    //@Ignore
    @Test
    @Transactional
    public void testQueries() throws ParseException {

        List<Project> projects = prr.findByName("Project1");    //it should return 1 project
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);

        projects = prr.findByNameLike("%proje%");           //it should return 5 projects 
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);          
        
        projects = prr.findByNameLikeOrderByBudgetDesc("%proje%");  //it should return 5 projects ordered pr5 to pr1
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);                  
        
        projects = prr.findByNameAndBudget("Project1",1000000); //it should return 1 project
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        

        projects = prr.findByBudgetGreaterThan(3000000);    //it should return 2 projects
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        
        
        projects = prr.findByBudgetLessThan(3000000);   //it should return 2 projects
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        

        projects = prr.findByBudgetIsNull();        //it should return 0 projects
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        

        projects = prr.findByIsfinishedTrue();        //it should return 1 project
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        

        projects = prr.findByIsfinished(false);        //it should return 4 project
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        
        
        projects = prr.findByStartdateBefore( (new SimpleDateFormat("dd-MM-yyyy")).parse("1-1-2015") );        //it should return 5 projects
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        

        projects = prr.findByStartdateAfterAndIsfinishedFalseAndBudgetLessThan( (new SimpleDateFormat("dd-MM-yyyy")).parse("1-1-1999"), 2000000 );  //it should return 1 project
        logger.info("SizeOfResults #:"+projects.size());
        printResults(projects);        
                
        projects = prr.findProjectsWhereASpecificUserIsInvolved(new Long(1));   //it should return 2 projects pr1 and pr3
        logger.info("SizeOfResults #: " + projects.size());
        printResults(projects);

        projects = prr.findProjectsWhereASpecificUserTypeIsInvolved(new Long(1));   //it should return 4 projects pr1 pr2 pr3 pr3
        logger.info("SizeOfResults #: " + projects.size());
        printResults(projects);

        projects = prr.findDistinctProjectsWhereASpecificUserTypeIsInvolved(new Long(1)); //it should return 3 projects pr1 pr2 pr3
        logger.info("SizeOfResults #: " + projects.size());
        printResults(projects);

        Long results = prr.countProjectsWhereASpecificUserTypeIsInvolved(new Long(1)); //it will return 4: pr1 pr3 pr2 and pr3
        logger.info("count #: " + results);
        //printResults(projects);
        
        results = prr.getTheBudgetofProjectsWhereASpecificUserTypeIsInvolved(new Long(1)); //it should return 9.000.000
        logger.info("sum #: " + results);
        //printResults(projects);
        
//        results = prr.getTheDistinctBudgetofProjectsWhereASpecificUserTypeIsInvolved(new Long(1)); //it should return 6.000.000
//        logger.info("sum #: " + results);
//        //printResults(projects);        
        
    }//EoM

    private static void printResults(List<?> objects) {
        if (objects != null && objects.size() > 0) {
            for (Object project : objects) {
                logger.info(project.toString());
            }//fir
        }//if
    }//EoM

}//EoC
